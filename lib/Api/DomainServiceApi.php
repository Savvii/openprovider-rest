<?php
/**
 * DomainServiceApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Savvii\OpenproviderRest
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * REST API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0-beta
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.3.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Savvii\OpenproviderRest\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Savvii\OpenproviderRest\ApiException;
use Savvii\OpenproviderRest\Configuration;
use Savvii\OpenproviderRest\HeaderSelector;
use Savvii\OpenproviderRest\ObjectSerializer;

/**
 * DomainServiceApi Class Doc Comment
 *
 * @category Class
 * @package  Savvii\OpenproviderRest
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DomainServiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'approveTransfer' => [
            'application/json',
        ],
        'checkDomain' => [
            'application/json',
        ],
        'createDomain' => [
            'application/json',
        ],
        'deleteDomain' => [
            'application/json',
        ],
        'getDomain' => [
            'application/json',
        ],
        'listDomains' => [
            'application/json',
        ],
        'renewDomain' => [
            'application/json',
        ],
        'restoreDomain' => [
            'application/json',
        ],
        'sendFoa1' => [
            'application/json',
        ],
        'suggestNameDomain' => [
            'application/json',
        ],
        'tradeDomain' => [
            'application/json',
        ],
        'transferDomain' => [
            'application/json',
        ],
        'tryAgainLastOperation' => [
            'application/json',
        ],
        'updateDomain' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation approveTransfer
     *
     * Approve transfer
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainApproveTransferRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\ResponseBoolResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function approveTransfer($id, $body, string $contentType = self::contentTypes['approveTransfer'][0])
    {
        list($response) = $this->approveTransferWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation approveTransferWithHttpInfo
     *
     * Approve transfer
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainApproveTransferRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\ResponseBoolResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function approveTransferWithHttpInfo($id, $body, string $contentType = self::contentTypes['approveTransfer'][0])
    {
        $request = $this->approveTransferRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\ResponseBoolResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ResponseBoolResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ResponseBoolResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\ResponseBoolResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ResponseBoolResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation approveTransferAsync
     *
     * Approve transfer
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainApproveTransferRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveTransferAsync($id, $body, string $contentType = self::contentTypes['approveTransfer'][0])
    {
        return $this->approveTransferAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation approveTransferAsyncWithHttpInfo
     *
     * Approve transfer
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainApproveTransferRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function approveTransferAsyncWithHttpInfo($id, $body, string $contentType = self::contentTypes['approveTransfer'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\ResponseBoolResponse';
        $request = $this->approveTransferRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'approveTransfer'
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainApproveTransferRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['approveTransfer'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function approveTransferRequest($id, $body, string $contentType = self::contentTypes['approveTransfer'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling approveTransfer'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling approveTransfer'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/transfer/approve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkDomain
     *
     * Check domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCheckDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainCheckDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function checkDomain($body, string $contentType = self::contentTypes['checkDomain'][0])
    {
        list($response) = $this->checkDomainWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation checkDomainWithHttpInfo
     *
     * Check domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCheckDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainCheckDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkDomainWithHttpInfo($body, string $contentType = self::contentTypes['checkDomain'][0])
    {
        $request = $this->checkDomainRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainCheckDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainCheckDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainCheckDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainCheckDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainCheckDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkDomainAsync
     *
     * Check domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCheckDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkDomainAsync($body, string $contentType = self::contentTypes['checkDomain'][0])
    {
        return $this->checkDomainAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkDomainAsyncWithHttpInfo
     *
     * Check domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCheckDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkDomainAsyncWithHttpInfo($body, string $contentType = self::contentTypes['checkDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainCheckDomainResponse';
        $request = $this->checkDomainRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkDomain'
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCheckDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkDomainRequest($body, string $contentType = self::contentTypes['checkDomain'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling checkDomain'
            );
        }


        $resourcePath = '/v1beta/domains/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createDomain
     *
     * Create domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCreateDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainCreateDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function createDomain($body, string $contentType = self::contentTypes['createDomain'][0])
    {
        list($response) = $this->createDomainWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation createDomainWithHttpInfo
     *
     * Create domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCreateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainCreateDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDomainWithHttpInfo($body, string $contentType = self::contentTypes['createDomain'][0])
    {
        $request = $this->createDomainRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainCreateDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainCreateDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainCreateDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainCreateDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainCreateDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDomainAsync
     *
     * Create domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCreateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDomainAsync($body, string $contentType = self::contentTypes['createDomain'][0])
    {
        return $this->createDomainAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDomainAsyncWithHttpInfo
     *
     * Create domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCreateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDomainAsyncWithHttpInfo($body, string $contentType = self::contentTypes['createDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainCreateDomainResponse';
        $request = $this->createDomainRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDomain'
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainCreateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createDomainRequest($body, string $contentType = self::contentTypes['createDomain'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createDomain'
            );
        }


        $resourcePath = '/v1beta/domains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDomain
     *
     * Delete domain
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  string $type Type of deletion request. (optional)
     * @param  bool $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  bool $force_delete Force delete domain even if it has glue records. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainDeleteDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function deleteDomain($id, $domain_name = null, $domain_extension = null, $type = null, $skip_soft_quarantine = null, $force_delete = null, string $contentType = self::contentTypes['deleteDomain'][0])
    {
        list($response) = $this->deleteDomainWithHttpInfo($id, $domain_name, $domain_extension, $type, $skip_soft_quarantine, $force_delete, $contentType);
        return $response;
    }

    /**
     * Operation deleteDomainWithHttpInfo
     *
     * Delete domain
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  string $type Type of deletion request. (optional)
     * @param  bool $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  bool $force_delete Force delete domain even if it has glue records. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainDeleteDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDomainWithHttpInfo($id, $domain_name = null, $domain_extension = null, $type = null, $skip_soft_quarantine = null, $force_delete = null, string $contentType = self::contentTypes['deleteDomain'][0])
    {
        $request = $this->deleteDomainRequest($id, $domain_name, $domain_extension, $type, $skip_soft_quarantine, $force_delete, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainDeleteDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainDeleteDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainDeleteDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainDeleteDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainDeleteDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDomainAsync
     *
     * Delete domain
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  string $type Type of deletion request. (optional)
     * @param  bool $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  bool $force_delete Force delete domain even if it has glue records. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDomainAsync($id, $domain_name = null, $domain_extension = null, $type = null, $skip_soft_quarantine = null, $force_delete = null, string $contentType = self::contentTypes['deleteDomain'][0])
    {
        return $this->deleteDomainAsyncWithHttpInfo($id, $domain_name, $domain_extension, $type, $skip_soft_quarantine, $force_delete, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDomainAsyncWithHttpInfo
     *
     * Delete domain
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  string $type Type of deletion request. (optional)
     * @param  bool $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  bool $force_delete Force delete domain even if it has glue records. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDomainAsyncWithHttpInfo($id, $domain_name = null, $domain_extension = null, $type = null, $skip_soft_quarantine = null, $force_delete = null, string $contentType = self::contentTypes['deleteDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainDeleteDomainResponse';
        $request = $this->deleteDomainRequest($id, $domain_name, $domain_extension, $type, $skip_soft_quarantine, $force_delete, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  string $type Type of deletion request. (optional)
     * @param  bool $skip_soft_quarantine Deletes domain, skipping the soft quarantine. (optional)
     * @param  bool $force_delete Force delete domain even if it has glue records. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteDomainRequest($id, $domain_name = null, $domain_extension = null, $type = null, $skip_soft_quarantine = null, $force_delete = null, string $contentType = self::contentTypes['deleteDomain'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDomain'
            );
        }







        $resourcePath = '/v1beta/domains/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_name,
            'domain.name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_extension,
            'domain.extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip_soft_quarantine,
            'skip_soft_quarantine', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force_delete,
            'force_delete', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDomain
     *
     * Get domain
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  bool $with_history Returns domain mutations history. (optional)
     * @param  bool $with_api_history Returns domain API calls history. (optional)
     * @param  bool $with_additional_data Returns domain additional data. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainGetDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function getDomain($id, $domain_name = null, $domain_extension = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $with_verification_email = null, $with_abuse_details = null, $with_whois_privacy_data = null, $with_registry_statuses = null, $is_deleted = null, string $contentType = self::contentTypes['getDomain'][0])
    {
        list($response) = $this->getDomainWithHttpInfo($id, $domain_name, $domain_extension, $with_history, $with_api_history, $with_additional_data, $with_verification_email, $with_abuse_details, $with_whois_privacy_data, $with_registry_statuses, $is_deleted, $contentType);
        return $response;
    }

    /**
     * Operation getDomainWithHttpInfo
     *
     * Get domain
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  bool $with_history Returns domain mutations history. (optional)
     * @param  bool $with_api_history Returns domain API calls history. (optional)
     * @param  bool $with_additional_data Returns domain additional data. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainGetDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDomainWithHttpInfo($id, $domain_name = null, $domain_extension = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $with_verification_email = null, $with_abuse_details = null, $with_whois_privacy_data = null, $with_registry_statuses = null, $is_deleted = null, string $contentType = self::contentTypes['getDomain'][0])
    {
        $request = $this->getDomainRequest($id, $domain_name, $domain_extension, $with_history, $with_api_history, $with_additional_data, $with_verification_email, $with_abuse_details, $with_whois_privacy_data, $with_registry_statuses, $is_deleted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainGetDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainGetDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainGetDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainGetDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainGetDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDomainAsync
     *
     * Get domain
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  bool $with_history Returns domain mutations history. (optional)
     * @param  bool $with_api_history Returns domain API calls history. (optional)
     * @param  bool $with_additional_data Returns domain additional data. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDomainAsync($id, $domain_name = null, $domain_extension = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $with_verification_email = null, $with_abuse_details = null, $with_whois_privacy_data = null, $with_registry_statuses = null, $is_deleted = null, string $contentType = self::contentTypes['getDomain'][0])
    {
        return $this->getDomainAsyncWithHttpInfo($id, $domain_name, $domain_extension, $with_history, $with_api_history, $with_additional_data, $with_verification_email, $with_abuse_details, $with_whois_privacy_data, $with_registry_statuses, $is_deleted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDomainAsyncWithHttpInfo
     *
     * Get domain
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  bool $with_history Returns domain mutations history. (optional)
     * @param  bool $with_api_history Returns domain API calls history. (optional)
     * @param  bool $with_additional_data Returns domain additional data. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDomainAsyncWithHttpInfo($id, $domain_name = null, $domain_extension = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $with_verification_email = null, $with_abuse_details = null, $with_whois_privacy_data = null, $with_registry_statuses = null, $is_deleted = null, string $contentType = self::contentTypes['getDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainGetDomainResponse';
        $request = $this->getDomainRequest($id, $domain_name, $domain_extension, $with_history, $with_api_history, $with_additional_data, $with_verification_email, $with_abuse_details, $with_whois_privacy_data, $with_registry_statuses, $is_deleted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  string $domain_name Domain name without extension. (optional)
     * @param  string $domain_extension Domain extension. (optional)
     * @param  bool $with_history Returns domain mutations history. (optional)
     * @param  bool $with_api_history Returns domain API calls history. (optional)
     * @param  bool $with_additional_data Returns domain additional data. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_abuse_details Returns domain abuse details. (optional)
     * @param  bool $with_whois_privacy_data Returns WPP data. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDomainRequest($id, $domain_name = null, $domain_extension = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $with_verification_email = null, $with_abuse_details = null, $with_whois_privacy_data = null, $with_registry_statuses = null, $is_deleted = null, string $contentType = self::contentTypes['getDomain'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDomain'
            );
        }












        $resourcePath = '/v1beta/domains/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_name,
            'domain.name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_extension,
            'domain.extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_history,
            'with_history', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_api_history,
            'with_api_history', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_additional_data,
            'with_additional_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_verification_email,
            'with_verification_email', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_abuse_details,
            'with_abuse_details', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_whois_privacy_data,
            'with_whois_privacy_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_registry_statuses,
            'with_registry_statuses', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_deleted,
            'is_deleted', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDomains
     *
     * List domains
     *
     * @param  string $order_by_id Domain id number. (optional)
     * @param  string $order_by_domain_name The domain name. (optional)
     * @param  string $order_by_domain_extension Domain extension. (optional)
     * @param  string $order_by_order_date The order date. (optional)
     * @param  string $order_by_active_date The active date. (optional)
     * @param  string $order_by_expiration_date Domain expiration date. (optional)
     * @param  string $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string $order_by_status Domain status. (optional)
     * @param  string $order_by_transfer_date The transfer date. (optional)
     * @param  int $limit The limit. (optional)
     * @param  int $offset The offset. (optional)
     * @param  int $id Domain id number. (optional)
     * @param  string $extension Domain extension. (optional)
     * @param  string $renewal_date Date on which domain will be renewed. (optional)
     * @param  string $full_name Full name of the domain. (optional)
     * @param  string $domain_name_pattern The domain name pattern. (optional)
     * @param  string $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string $status Domain status. (optional)
     * @param  string[] $status_not_equal Array of domain statuses to exclude. (optional)
     * @param  string $queue_status The queue status. (optional)
     * @param  string $contact_handle Handle to filter by. (optional)
     * @param  string $comment_pattern The comment pattern. (optional)
     * @param  bool $with_history With history. (optional)
     * @param  bool $with_api_history With api history. (optional)
     * @param  bool $with_additional_data With additional data. (optional)
     * @param  string $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string $response_type The type. (optional)
     * @param  string $response_to The to. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainListDomainsResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function listDomains($order_by_id = null, $order_by_domain_name = null, $order_by_domain_extension = null, $order_by_order_date = null, $order_by_active_date = null, $order_by_expiration_date = null, $order_by_renewal_date = null, $order_by_status = null, $order_by_transfer_date = null, $limit = null, $offset = null, $id = null, $extension = null, $renewal_date = null, $full_name = null, $domain_name_pattern = null, $ns_group_pattern = null, $status = null, $status_not_equal = null, $queue_status = null, $contact_handle = null, $comment_pattern = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $application_mode = null, $with_verification_email = null, $with_registry_statuses = null, $response_type = null, $response_to = null, $is_deleted = null, string $contentType = self::contentTypes['listDomains'][0])
    {
        list($response) = $this->listDomainsWithHttpInfo($order_by_id, $order_by_domain_name, $order_by_domain_extension, $order_by_order_date, $order_by_active_date, $order_by_expiration_date, $order_by_renewal_date, $order_by_status, $order_by_transfer_date, $limit, $offset, $id, $extension, $renewal_date, $full_name, $domain_name_pattern, $ns_group_pattern, $status, $status_not_equal, $queue_status, $contact_handle, $comment_pattern, $with_history, $with_api_history, $with_additional_data, $application_mode, $with_verification_email, $with_registry_statuses, $response_type, $response_to, $is_deleted, $contentType);
        return $response;
    }

    /**
     * Operation listDomainsWithHttpInfo
     *
     * List domains
     *
     * @param  string $order_by_id Domain id number. (optional)
     * @param  string $order_by_domain_name The domain name. (optional)
     * @param  string $order_by_domain_extension Domain extension. (optional)
     * @param  string $order_by_order_date The order date. (optional)
     * @param  string $order_by_active_date The active date. (optional)
     * @param  string $order_by_expiration_date Domain expiration date. (optional)
     * @param  string $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string $order_by_status Domain status. (optional)
     * @param  string $order_by_transfer_date The transfer date. (optional)
     * @param  int $limit The limit. (optional)
     * @param  int $offset The offset. (optional)
     * @param  int $id Domain id number. (optional)
     * @param  string $extension Domain extension. (optional)
     * @param  string $renewal_date Date on which domain will be renewed. (optional)
     * @param  string $full_name Full name of the domain. (optional)
     * @param  string $domain_name_pattern The domain name pattern. (optional)
     * @param  string $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string $status Domain status. (optional)
     * @param  string[] $status_not_equal Array of domain statuses to exclude. (optional)
     * @param  string $queue_status The queue status. (optional)
     * @param  string $contact_handle Handle to filter by. (optional)
     * @param  string $comment_pattern The comment pattern. (optional)
     * @param  bool $with_history With history. (optional)
     * @param  bool $with_api_history With api history. (optional)
     * @param  bool $with_additional_data With additional data. (optional)
     * @param  string $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string $response_type The type. (optional)
     * @param  string $response_to The to. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainListDomainsResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listDomainsWithHttpInfo($order_by_id = null, $order_by_domain_name = null, $order_by_domain_extension = null, $order_by_order_date = null, $order_by_active_date = null, $order_by_expiration_date = null, $order_by_renewal_date = null, $order_by_status = null, $order_by_transfer_date = null, $limit = null, $offset = null, $id = null, $extension = null, $renewal_date = null, $full_name = null, $domain_name_pattern = null, $ns_group_pattern = null, $status = null, $status_not_equal = null, $queue_status = null, $contact_handle = null, $comment_pattern = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $application_mode = null, $with_verification_email = null, $with_registry_statuses = null, $response_type = null, $response_to = null, $is_deleted = null, string $contentType = self::contentTypes['listDomains'][0])
    {
        $request = $this->listDomainsRequest($order_by_id, $order_by_domain_name, $order_by_domain_extension, $order_by_order_date, $order_by_active_date, $order_by_expiration_date, $order_by_renewal_date, $order_by_status, $order_by_transfer_date, $limit, $offset, $id, $extension, $renewal_date, $full_name, $domain_name_pattern, $ns_group_pattern, $status, $status_not_equal, $queue_status, $contact_handle, $comment_pattern, $with_history, $with_api_history, $with_additional_data, $application_mode, $with_verification_email, $with_registry_statuses, $response_type, $response_to, $is_deleted, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainListDomainsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainListDomainsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainListDomainsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainListDomainsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainListDomainsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listDomainsAsync
     *
     * List domains
     *
     * @param  string $order_by_id Domain id number. (optional)
     * @param  string $order_by_domain_name The domain name. (optional)
     * @param  string $order_by_domain_extension Domain extension. (optional)
     * @param  string $order_by_order_date The order date. (optional)
     * @param  string $order_by_active_date The active date. (optional)
     * @param  string $order_by_expiration_date Domain expiration date. (optional)
     * @param  string $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string $order_by_status Domain status. (optional)
     * @param  string $order_by_transfer_date The transfer date. (optional)
     * @param  int $limit The limit. (optional)
     * @param  int $offset The offset. (optional)
     * @param  int $id Domain id number. (optional)
     * @param  string $extension Domain extension. (optional)
     * @param  string $renewal_date Date on which domain will be renewed. (optional)
     * @param  string $full_name Full name of the domain. (optional)
     * @param  string $domain_name_pattern The domain name pattern. (optional)
     * @param  string $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string $status Domain status. (optional)
     * @param  string[] $status_not_equal Array of domain statuses to exclude. (optional)
     * @param  string $queue_status The queue status. (optional)
     * @param  string $contact_handle Handle to filter by. (optional)
     * @param  string $comment_pattern The comment pattern. (optional)
     * @param  bool $with_history With history. (optional)
     * @param  bool $with_api_history With api history. (optional)
     * @param  bool $with_additional_data With additional data. (optional)
     * @param  string $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string $response_type The type. (optional)
     * @param  string $response_to The to. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDomainsAsync($order_by_id = null, $order_by_domain_name = null, $order_by_domain_extension = null, $order_by_order_date = null, $order_by_active_date = null, $order_by_expiration_date = null, $order_by_renewal_date = null, $order_by_status = null, $order_by_transfer_date = null, $limit = null, $offset = null, $id = null, $extension = null, $renewal_date = null, $full_name = null, $domain_name_pattern = null, $ns_group_pattern = null, $status = null, $status_not_equal = null, $queue_status = null, $contact_handle = null, $comment_pattern = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $application_mode = null, $with_verification_email = null, $with_registry_statuses = null, $response_type = null, $response_to = null, $is_deleted = null, string $contentType = self::contentTypes['listDomains'][0])
    {
        return $this->listDomainsAsyncWithHttpInfo($order_by_id, $order_by_domain_name, $order_by_domain_extension, $order_by_order_date, $order_by_active_date, $order_by_expiration_date, $order_by_renewal_date, $order_by_status, $order_by_transfer_date, $limit, $offset, $id, $extension, $renewal_date, $full_name, $domain_name_pattern, $ns_group_pattern, $status, $status_not_equal, $queue_status, $contact_handle, $comment_pattern, $with_history, $with_api_history, $with_additional_data, $application_mode, $with_verification_email, $with_registry_statuses, $response_type, $response_to, $is_deleted, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDomainsAsyncWithHttpInfo
     *
     * List domains
     *
     * @param  string $order_by_id Domain id number. (optional)
     * @param  string $order_by_domain_name The domain name. (optional)
     * @param  string $order_by_domain_extension Domain extension. (optional)
     * @param  string $order_by_order_date The order date. (optional)
     * @param  string $order_by_active_date The active date. (optional)
     * @param  string $order_by_expiration_date Domain expiration date. (optional)
     * @param  string $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string $order_by_status Domain status. (optional)
     * @param  string $order_by_transfer_date The transfer date. (optional)
     * @param  int $limit The limit. (optional)
     * @param  int $offset The offset. (optional)
     * @param  int $id Domain id number. (optional)
     * @param  string $extension Domain extension. (optional)
     * @param  string $renewal_date Date on which domain will be renewed. (optional)
     * @param  string $full_name Full name of the domain. (optional)
     * @param  string $domain_name_pattern The domain name pattern. (optional)
     * @param  string $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string $status Domain status. (optional)
     * @param  string[] $status_not_equal Array of domain statuses to exclude. (optional)
     * @param  string $queue_status The queue status. (optional)
     * @param  string $contact_handle Handle to filter by. (optional)
     * @param  string $comment_pattern The comment pattern. (optional)
     * @param  bool $with_history With history. (optional)
     * @param  bool $with_api_history With api history. (optional)
     * @param  bool $with_additional_data With additional data. (optional)
     * @param  string $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string $response_type The type. (optional)
     * @param  string $response_to The to. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDomainsAsyncWithHttpInfo($order_by_id = null, $order_by_domain_name = null, $order_by_domain_extension = null, $order_by_order_date = null, $order_by_active_date = null, $order_by_expiration_date = null, $order_by_renewal_date = null, $order_by_status = null, $order_by_transfer_date = null, $limit = null, $offset = null, $id = null, $extension = null, $renewal_date = null, $full_name = null, $domain_name_pattern = null, $ns_group_pattern = null, $status = null, $status_not_equal = null, $queue_status = null, $contact_handle = null, $comment_pattern = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $application_mode = null, $with_verification_email = null, $with_registry_statuses = null, $response_type = null, $response_to = null, $is_deleted = null, string $contentType = self::contentTypes['listDomains'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainListDomainsResponse';
        $request = $this->listDomainsRequest($order_by_id, $order_by_domain_name, $order_by_domain_extension, $order_by_order_date, $order_by_active_date, $order_by_expiration_date, $order_by_renewal_date, $order_by_status, $order_by_transfer_date, $limit, $offset, $id, $extension, $renewal_date, $full_name, $domain_name_pattern, $ns_group_pattern, $status, $status_not_equal, $queue_status, $contact_handle, $comment_pattern, $with_history, $with_api_history, $with_additional_data, $application_mode, $with_verification_email, $with_registry_statuses, $response_type, $response_to, $is_deleted, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDomains'
     *
     * @param  string $order_by_id Domain id number. (optional)
     * @param  string $order_by_domain_name The domain name. (optional)
     * @param  string $order_by_domain_extension Domain extension. (optional)
     * @param  string $order_by_order_date The order date. (optional)
     * @param  string $order_by_active_date The active date. (optional)
     * @param  string $order_by_expiration_date Domain expiration date. (optional)
     * @param  string $order_by_renewal_date Date on which domain will be renewed. (optional)
     * @param  string $order_by_status Domain status. (optional)
     * @param  string $order_by_transfer_date The transfer date. (optional)
     * @param  int $limit The limit. (optional)
     * @param  int $offset The offset. (optional)
     * @param  int $id Domain id number. (optional)
     * @param  string $extension Domain extension. (optional)
     * @param  string $renewal_date Date on which domain will be renewed. (optional)
     * @param  string $full_name Full name of the domain. (optional)
     * @param  string $domain_name_pattern The domain name pattern. (optional)
     * @param  string $ns_group_pattern Nameserver group name pattern. (optional)
     * @param  string $status Domain status. (optional)
     * @param  string[] $status_not_equal Array of domain statuses to exclude. (optional)
     * @param  string $queue_status The queue status. (optional)
     * @param  string $contact_handle Handle to filter by. (optional)
     * @param  string $comment_pattern The comment pattern. (optional)
     * @param  bool $with_history With history. (optional)
     * @param  bool $with_api_history With api history. (optional)
     * @param  bool $with_additional_data With additional data. (optional)
     * @param  string $application_mode When new gTLD is started it gets through several phases before it becomes available for registration to everybody (General availability or GA). There are several phases before GA when it is still possible to apply for a domain, but with some restrictions. (optional)
     * @param  bool $with_verification_email Returns information about domain owner email verification status. (optional)
     * @param  bool $with_registry_statuses Indicates, if registry EPP statuses should be retrieved. (optional)
     * @param  string $response_type The type. (optional)
     * @param  string $response_to The to. (optional)
     * @param  bool $is_deleted Indicates whether object is deleted. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listDomains'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listDomainsRequest($order_by_id = null, $order_by_domain_name = null, $order_by_domain_extension = null, $order_by_order_date = null, $order_by_active_date = null, $order_by_expiration_date = null, $order_by_renewal_date = null, $order_by_status = null, $order_by_transfer_date = null, $limit = null, $offset = null, $id = null, $extension = null, $renewal_date = null, $full_name = null, $domain_name_pattern = null, $ns_group_pattern = null, $status = null, $status_not_equal = null, $queue_status = null, $contact_handle = null, $comment_pattern = null, $with_history = null, $with_api_history = null, $with_additional_data = null, $application_mode = null, $with_verification_email = null, $with_registry_statuses = null, $response_type = null, $response_to = null, $is_deleted = null, string $contentType = self::contentTypes['listDomains'][0])
    {

































        $resourcePath = '/v1beta/domains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_id,
            'order_by.id', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_domain_name,
            'order_by.domain_name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_domain_extension,
            'order_by.domain_extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_order_date,
            'order_by.order_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_active_date,
            'order_by.active_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_expiration_date,
            'order_by.expiration_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_renewal_date,
            'order_by.renewal_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_status,
            'order_by.status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_by_transfer_date,
            'order_by.transfer_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extension,
            'extension', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $renewal_date,
            'renewal_date', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $full_name,
            'full_name', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $domain_name_pattern,
            'domain_name_pattern', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ns_group_pattern,
            'ns_group_pattern', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status_not_equal,
            'status_not_equal', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $queue_status,
            'queue_status', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contact_handle,
            'contact_handle', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment_pattern,
            'comment_pattern', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_history,
            'with_history', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_api_history,
            'with_api_history', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_additional_data,
            'with_additional_data', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $application_mode,
            'application_mode', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_verification_email,
            'with_verification_email', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $with_registry_statuses,
            'with_registry_statuses', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_type,
            'response.type', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $response_to,
            'response.to', // param base name
            'string', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_deleted,
            'is_deleted', // param base name
            'boolean', // openApiType
            '', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renewDomain
     *
     * Renew domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRenewDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainRenewDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function renewDomain($id, $body, string $contentType = self::contentTypes['renewDomain'][0])
    {
        list($response) = $this->renewDomainWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation renewDomainWithHttpInfo
     *
     * Renew domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRenewDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainRenewDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function renewDomainWithHttpInfo($id, $body, string $contentType = self::contentTypes['renewDomain'][0])
    {
        $request = $this->renewDomainRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainRenewDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainRenewDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainRenewDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainRenewDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainRenewDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renewDomainAsync
     *
     * Renew domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRenewDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renewDomainAsync($id, $body, string $contentType = self::contentTypes['renewDomain'][0])
    {
        return $this->renewDomainAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renewDomainAsyncWithHttpInfo
     *
     * Renew domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRenewDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renewDomainAsyncWithHttpInfo($id, $body, string $contentType = self::contentTypes['renewDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainRenewDomainResponse';
        $request = $this->renewDomainRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renewDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRenewDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renewDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function renewDomainRequest($id, $body, string $contentType = self::contentTypes['renewDomain'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling renewDomain'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling renewDomain'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/renew';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restoreDomain
     *
     * Restore domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRestoreDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainRestoreDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function restoreDomain($id, $body, string $contentType = self::contentTypes['restoreDomain'][0])
    {
        list($response) = $this->restoreDomainWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation restoreDomainWithHttpInfo
     *
     * Restore domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRestoreDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainRestoreDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function restoreDomainWithHttpInfo($id, $body, string $contentType = self::contentTypes['restoreDomain'][0])
    {
        $request = $this->restoreDomainRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainRestoreDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainRestoreDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainRestoreDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainRestoreDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainRestoreDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation restoreDomainAsync
     *
     * Restore domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRestoreDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreDomainAsync($id, $body, string $contentType = self::contentTypes['restoreDomain'][0])
    {
        return $this->restoreDomainAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restoreDomainAsyncWithHttpInfo
     *
     * Restore domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRestoreDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreDomainAsyncWithHttpInfo($id, $body, string $contentType = self::contentTypes['restoreDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainRestoreDomainResponse';
        $request = $this->restoreDomainRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restoreDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainRestoreDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restoreDomainRequest($id, $body, string $contentType = self::contentTypes['restoreDomain'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling restoreDomain'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling restoreDomain'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/restore';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendFoa1
     *
     * Send foa1
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainSendFoa1Request $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\ResponseBoolResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function sendFoa1($id, $body, string $contentType = self::contentTypes['sendFoa1'][0])
    {
        list($response) = $this->sendFoa1WithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation sendFoa1WithHttpInfo
     *
     * Send foa1
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainSendFoa1Request $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\ResponseBoolResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendFoa1WithHttpInfo($id, $body, string $contentType = self::contentTypes['sendFoa1'][0])
    {
        $request = $this->sendFoa1Request($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\ResponseBoolResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ResponseBoolResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ResponseBoolResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\ResponseBoolResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ResponseBoolResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendFoa1Async
     *
     * Send foa1
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainSendFoa1Request $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendFoa1Async($id, $body, string $contentType = self::contentTypes['sendFoa1'][0])
    {
        return $this->sendFoa1AsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendFoa1AsyncWithHttpInfo
     *
     * Send foa1
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainSendFoa1Request $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendFoa1AsyncWithHttpInfo($id, $body, string $contentType = self::contentTypes['sendFoa1'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\ResponseBoolResponse';
        $request = $this->sendFoa1Request($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendFoa1'
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainSendFoa1Request $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendFoa1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendFoa1Request($id, $body, string $contentType = self::contentTypes['sendFoa1'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling sendFoa1'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling sendFoa1'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/transfer/send-foa1';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation suggestNameDomain
     *
     * Suggest name domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainSuggestNameDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['suggestNameDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainSuggestNameDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function suggestNameDomain($body, string $contentType = self::contentTypes['suggestNameDomain'][0])
    {
        list($response) = $this->suggestNameDomainWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation suggestNameDomainWithHttpInfo
     *
     * Suggest name domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainSuggestNameDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['suggestNameDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainSuggestNameDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function suggestNameDomainWithHttpInfo($body, string $contentType = self::contentTypes['suggestNameDomain'][0])
    {
        $request = $this->suggestNameDomainRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainSuggestNameDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainSuggestNameDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainSuggestNameDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainSuggestNameDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainSuggestNameDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation suggestNameDomainAsync
     *
     * Suggest name domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainSuggestNameDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['suggestNameDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function suggestNameDomainAsync($body, string $contentType = self::contentTypes['suggestNameDomain'][0])
    {
        return $this->suggestNameDomainAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation suggestNameDomainAsyncWithHttpInfo
     *
     * Suggest name domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainSuggestNameDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['suggestNameDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function suggestNameDomainAsyncWithHttpInfo($body, string $contentType = self::contentTypes['suggestNameDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainSuggestNameDomainResponse';
        $request = $this->suggestNameDomainRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'suggestNameDomain'
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainSuggestNameDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['suggestNameDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function suggestNameDomainRequest($body, string $contentType = self::contentTypes['suggestNameDomain'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling suggestNameDomain'
            );
        }


        $resourcePath = '/v1beta/domains/suggest-name';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tradeDomain
     *
     * Trade domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTradeDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainTradeDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function tradeDomain($body, string $contentType = self::contentTypes['tradeDomain'][0])
    {
        list($response) = $this->tradeDomainWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation tradeDomainWithHttpInfo
     *
     * Trade domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTradeDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainTradeDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function tradeDomainWithHttpInfo($body, string $contentType = self::contentTypes['tradeDomain'][0])
    {
        $request = $this->tradeDomainRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainTradeDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainTradeDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainTradeDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainTradeDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainTradeDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tradeDomainAsync
     *
     * Trade domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTradeDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tradeDomainAsync($body, string $contentType = self::contentTypes['tradeDomain'][0])
    {
        return $this->tradeDomainAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tradeDomainAsyncWithHttpInfo
     *
     * Trade domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTradeDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tradeDomainAsyncWithHttpInfo($body, string $contentType = self::contentTypes['tradeDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainTradeDomainResponse';
        $request = $this->tradeDomainRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tradeDomain'
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTradeDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tradeDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tradeDomainRequest($body, string $contentType = self::contentTypes['tradeDomain'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling tradeDomain'
            );
        }


        $resourcePath = '/v1beta/domains/trade';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation transferDomain
     *
     * Transfer domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTransferDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainTransferDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function transferDomain($body, string $contentType = self::contentTypes['transferDomain'][0])
    {
        list($response) = $this->transferDomainWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation transferDomainWithHttpInfo
     *
     * Transfer domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTransferDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainTransferDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function transferDomainWithHttpInfo($body, string $contentType = self::contentTypes['transferDomain'][0])
    {
        $request = $this->transferDomainRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainTransferDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainTransferDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainTransferDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainTransferDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainTransferDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation transferDomainAsync
     *
     * Transfer domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTransferDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferDomainAsync($body, string $contentType = self::contentTypes['transferDomain'][0])
    {
        return $this->transferDomainAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation transferDomainAsyncWithHttpInfo
     *
     * Transfer domain
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTransferDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function transferDomainAsyncWithHttpInfo($body, string $contentType = self::contentTypes['transferDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainTransferDomainResponse';
        $request = $this->transferDomainRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'transferDomain'
     *
     * @param  \Savvii\OpenproviderRest\Model\DomainTransferDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['transferDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function transferDomainRequest($body, string $contentType = self::contentTypes['transferDomain'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling transferDomain'
            );
        }


        $resourcePath = '/v1beta/domains/transfer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation tryAgainLastOperation
     *
     * Try again last operation
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainTryAgainLastOperationRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\ResponseBoolResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function tryAgainLastOperation($id, $body, string $contentType = self::contentTypes['tryAgainLastOperation'][0])
    {
        list($response) = $this->tryAgainLastOperationWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation tryAgainLastOperationWithHttpInfo
     *
     * Try again last operation
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainTryAgainLastOperationRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\ResponseBoolResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function tryAgainLastOperationWithHttpInfo($id, $body, string $contentType = self::contentTypes['tryAgainLastOperation'][0])
    {
        $request = $this->tryAgainLastOperationRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\ResponseBoolResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ResponseBoolResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ResponseBoolResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\ResponseBoolResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ResponseBoolResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation tryAgainLastOperationAsync
     *
     * Try again last operation
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainTryAgainLastOperationRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tryAgainLastOperationAsync($id, $body, string $contentType = self::contentTypes['tryAgainLastOperation'][0])
    {
        return $this->tryAgainLastOperationAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation tryAgainLastOperationAsyncWithHttpInfo
     *
     * Try again last operation
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainTryAgainLastOperationRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function tryAgainLastOperationAsyncWithHttpInfo($id, $body, string $contentType = self::contentTypes['tryAgainLastOperation'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\ResponseBoolResponse';
        $request = $this->tryAgainLastOperationRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'tryAgainLastOperation'
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainTryAgainLastOperationRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['tryAgainLastOperation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function tryAgainLastOperationRequest($id, $body, string $contentType = self::contentTypes['tryAgainLastOperation'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling tryAgainLastOperation'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling tryAgainLastOperation'
            );
        }


        $resourcePath = '/v1beta/domains/{id}/last-operation/restart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDomain
     *
     * Update domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainUpdateDomainRequest $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Savvii\OpenproviderRest\Model\DomainUpdateDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError
     */
    public function updateDomain($id, $body, string $contentType = self::contentTypes['updateDomain'][0])
    {
        list($response) = $this->updateDomainWithHttpInfo($id, $body, $contentType);
        return $response;
    }

    /**
     * Operation updateDomainWithHttpInfo
     *
     * Update domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainUpdateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws \Savvii\OpenproviderRest\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Savvii\OpenproviderRest\Model\DomainUpdateDomainResponse|\Savvii\OpenproviderRest\Model\ErrorError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDomainWithHttpInfo($id, $body, string $contentType = self::contentTypes['updateDomain'][0])
    {
        $request = $this->updateDomainRequest($id, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Savvii\OpenproviderRest\Model\DomainUpdateDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\DomainUpdateDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\DomainUpdateDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Savvii\OpenproviderRest\Model\ErrorError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Savvii\OpenproviderRest\Model\ErrorError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Savvii\OpenproviderRest\Model\ErrorError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Savvii\OpenproviderRest\Model\DomainUpdateDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\DomainUpdateDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Savvii\OpenproviderRest\Model\ErrorError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDomainAsync
     *
     * Update domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainUpdateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDomainAsync($id, $body, string $contentType = self::contentTypes['updateDomain'][0])
    {
        return $this->updateDomainAsyncWithHttpInfo($id, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDomainAsyncWithHttpInfo
     *
     * Update domain
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainUpdateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDomainAsyncWithHttpInfo($id, $body, string $contentType = self::contentTypes['updateDomain'][0])
    {
        $returnType = '\Savvii\OpenproviderRest\Model\DomainUpdateDomainResponse';
        $request = $this->updateDomainRequest($id, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDomain'
     *
     * @param  int $id Domain id number (required)
     * @param  \Savvii\OpenproviderRest\Model\DomainUpdateDomainRequest $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateDomainRequest($id, $body, string $contentType = self::contentTypes['updateDomain'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateDomain'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateDomain'
            );
        }


        $resourcePath = '/v1beta/domains/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
